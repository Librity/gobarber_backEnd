sudo docker run --name database -e POSTGRES_PASSWORD=docker -p 5433:5432 -d postgres:11
UN: postgres
PW: docker
docker stop database
docker start database
docker logs database
docker ps -a
docker stop $(docker ps -a -q); docker rm $(docker ps -a -q);

Object-Relational-Mapper => Sequelize
^^^What interprets between your node app & your whataver DB&SQX
With this, we don't have to write migarations, entries and queries in SQL;
Migrations => database version control
(!migration == rollback)true

example:
module.export = {
  up: (queryInterface, Sequelize) => {
    return queryInterface.createTable("users", {
      id: {
        allowNull: false,
        autoIncrement:true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      name: {
        allowNull:false,
        type: Sequelize.STRING
      },
      email: {
        allowNull:false,
        unique:true,
        type: Sequelize.STRING
      }
    })
  },

  down: (queryInterface, Sequelize) => {
    return queryInterface.dropTable("Users")
  }
}
up runs for the migration, down for the rollback;
any up must have a down (at least it should);
!!There's no ROLLBACKS in production environments!!
* One table/migration;
Seeds => they populate fake elements in our DB for examples, testing, etc.
!!Never use SEEDS in PRODUCTION!!
Seeds != DatabaseConstants

MVC Architecture
Model       => DB abstraction, manipulates data in DB;
View        => The response data (what the clients recieve); non-API=>HTML
Controller  => What interacts with the two above, where the server operates;
  An Object class, that returns a JSON (RESTAPI) & NEVER calls another controller;
  You should have a controller for each Model, but you don't need a controller w/
  a model (like authentication => sessions.controller);